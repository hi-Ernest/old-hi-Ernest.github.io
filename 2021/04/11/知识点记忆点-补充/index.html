<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>知识点记忆点-补充 · Ernest's blog</title><meta name="description" content="什么是微服务？将单体系统拆分职责相对于单一的一个个项目，每个项目提供不同的服务内容，服务之间的通过rpc来调用
一个服务的宕机、不可用，不会影响上下游服务，做到服务熔断隔离。根据每个服务访问流量的大小，指定服务的扩容和缩容，更加独立的进行，减少不必要资源的消耗。

Java基础抽象类和接口的区分？什"><meta name="og:description" content="什么是微服务？将单体系统拆分职责相对于单一的一个个项目，每个项目提供不同的服务内容，服务之间的通过rpc来调用
一个服务的宕机、不可用，不会影响上下游服务，做到服务熔断隔离。根据每个服务访问流量的大小，指定服务的扩容和缩容，更加独立的进行，减少不必要资源的消耗。

Java基础抽象类和接口的区分？什"><meta name="twitter:site" content="Ernest's blog"><meta name="twitter:title" content="知识点记忆点-补充"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">Get better every day</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">日拱一卒</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/about-me/index.html">about me</a></li><li><a href="/categories/index.html">categories</a></li><li><a href="/tags/index.html">tags</a></li><li><a href="/works/index.html">resume</a></li><li class="soc"><a href="https://ruihuachen.github.io/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://ruihuachen.github.io" rel="noopener noreferrer">Ernest's blog</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>知识点记忆点-补充</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2021-04-11</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/学习/" title="学习" class="a-tag">学习</a><span>&nbsp;</span></span></p><p class="post-abstract"><h3 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h3><p>将单体系统拆分职责相对于单一的一个个项目，每个项目提供不同的服务内容，服务之间的通过rpc来调用</p>
<p>一个服务的宕机、不可用，不会影响上下游服务，做到服务熔断隔离。根据每个服务访问流量的大小，指定服务的扩容和缩容，更加独立的进行，减少不必要资源的消耗。</p>
<hr>
<h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p><em><strong>抽象类和接口的区分？什么时候用接口 什么时候用抽象类?</strong></em></p>
<ol>
<li><p>抽象类主要是复用代码，将不同类具有相同行为A属性，交给抽象类实现，避免子类都去实现</p>
</li>
<li><p>接口只能定义方法（类行为的约束），类可以实现接口重写必须实现的方法，也可以额外写其他行为方法</p>
</li>
</ol>
<hr>
<h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><h4 id="GC-Roots指的是哪些对象？"><a href="#GC-Roots指的是哪些对象？" class="headerlink" title="GC Roots指的是哪些对象？"></a>GC Roots指的是哪些对象？</h4><ol>
<li><p>JVM栈中本地变量表中引用的对象</p>
</li>
<li><p>方法区中类静态属性引用变量</p>
</li>
<li><p>方法区中常量引用对象</p>
</li>
<li><p>本地方法栈中Native方法</p>
</li>
</ol>
<h4 id="方法区的回收有哪些对象？"><a href="#方法区的回收有哪些对象？" class="headerlink" title="方法区的回收有哪些对象？"></a>方法区的回收有哪些对象？</h4><p><em><strong>废弃常量的回收、无用类的回收</strong></em></p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。<br>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<hr>
<h3 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h3><h4 id="Spring和SpringBoot的区别？"><a href="#Spring和SpringBoot的区别？" class="headerlink" title="Spring和SpringBoot的区别？"></a>Spring和SpringBoot的区别？</h4><ul>
<li><p>springboot极大简化spring所需要的配置</p>
</li>
<li><p>内嵌了tomcat容器 简化部署</p>
</li>
<li><p>引入starters 集合应用依赖包 快速搭建业务框架</p>
</li>
</ul>
<hr>
<h4 id="Spring的事务隔离级别有哪些？（四种）"><a href="#Spring的事务隔离级别有哪些？（四种）" class="headerlink" title="Spring的事务隔离级别有哪些？（四种）"></a>Spring的事务隔离级别有哪些？（四种）</h4><p>采用默认的隔离级别（DB是怎样隔离级别 那Spring就是怎样的隔离级别）[MySQL默认是<strong>可重复读</strong>]</p>
<ol>
<li><p>读未提交（read uncommited）[脏读、不可重复读、幻读]</p>
</li>
<li><p>读已提交（read commited）[避免脏读，但可能不可重复读、幻读]</p>
</li>
<li><p>可重复读（repeatable read）[避免脏读和不可重复读，但可能幻读]</p>
</li>
<li><p>串行化（Serializable）[避免以上问题]</p>
</li>
</ol>
<hr>
<h4 id="Spring的事务传播级别有哪些？（七种传播行为）"><a href="#Spring的事务传播级别有哪些？（七种传播行为）" class="headerlink" title="Spring的事务传播级别有哪些？（七种传播行为）"></a>Spring的事务传播级别有哪些？（七种传播行为）</h4><p><em><strong>支持当前事务：</strong></em></p>
<ul>
<li><p>当前有事务加入事务，没有事务，新建事务</p>
</li>
<li><p>当前有事务加入事务，没有事务，以非事务方式运行</p>
</li>
<li><p>当前有事务加入事务，没有事务，抛弃异常</p>
</li>
</ul>
<hr>
<p><em><strong>不支持当前事务情况：</strong></em></p>
<p>前提：t &lt;- 事务（transaction）</p>
<ul>
<li><p>if 当前 ∃ t -&gt; t 挂起，创建新的事务t’</p>
</li>
<li><p>以非事务的方式运行，if 当前 ∃ t -&gt; t 挂起</p>
</li>
<li><p>以非事务的方式运行，if 当前 ∃ t -&gt; thows exception</p>
</li>
<li><p>If 当前∃ t -&gt; 则创建一个事务作为当前事务的嵌套事务运行</p>
</li>
</ul>
<hr>
<h4 id="Spring中有哪些设计模式？分别有哪些"><a href="#Spring中有哪些设计模式？分别有哪些" class="headerlink" title="Spring中有哪些设计模式？分别有哪些"></a>Spring中有哪些设计模式？分别有哪些</h4><p>IOC：工厂模式 + 反射</p>
<p>AOP：代理模式</p>
<p>JDBCTemplate：模版模式</p>
<p>Spring中Bean：单例模式</p>
<p>SpringMVC中的适配器HandlerAdatper：适配器模式</p>
<p>spring的事件驱动模型（ApplicationListener）：观察者模式 </p>
<p>Spring中Observer模式常用的地方是listener的实现</p>
<p>Spring装饰器模式：在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1593982">https://cloud.tencent.com/developer/article/1593982</a></p>
<hr>
<h4 id="代理模式和装饰器模式的区别？"><a href="#代理模式和装饰器模式的区别？" class="headerlink" title="代理模式和装饰器模式的区别？"></a>代理模式和装饰器模式的区别？</h4><p>代理模式是对代理对象加以控制，比如在对象前置或者后置，帮助你完成其他不用关心的事情，比如日志</p>
<p>装饰器模式是对装饰对象功能的增强，还是调用之前的方法，但有新的功能，是继承的替代模式</p>
<hr>
<h4 id="有哪些方法可以实现单例模式？"><a href="#有哪些方法可以实现单例模式？" class="headerlink" title="有哪些方法可以实现单例模式？"></a>有哪些方法可以实现单例模式？</h4><p>懒汉式（当只有在使用时才进行类对象创建）</p>
<p>饿汉式（静态常量、静态代码块）</p>
<p>双重检验锁也是懒汉式</p>
<p><strong>静态内部类（静态属性只有在第一次加载类的时候初始化，通过getInstance）</strong></p>
<p><strong>枚举</strong></p>
<hr>
<h3 id="数据库MySQL"><a href="#数据库MySQL" class="headerlink" title="数据库MySQL"></a>数据库MySQL</h3><h4 id="数据库的事务特性？（四个）"><a href="#数据库的事务特性？（四个）" class="headerlink" title="数据库的事务特性？（四个）"></a>数据库的事务特性？（四个）</h4><p>原子性、一致性、隔离性、持久性</p>
<hr>
<h3 id="MySQL的事物并发问题"><a href="#MySQL的事物并发问题" class="headerlink" title="MySQL的事物并发问题"></a>MySQL的事物并发问题</h3><p>脏读、不可重复读、幻读</p>
<hr>
<h3 id="MySQL事物隔离级别"><a href="#MySQL事物隔离级别" class="headerlink" title="MySQL事物隔离级别"></a>MySQL事物隔离级别</h3><p>读未提交、读已提交、可重复读、可串行化</p>
<hr>
<h4 id="什么是MVCC？怎么解决并发一致性问题"><a href="#什么是MVCC？怎么解决并发一致性问题" class="headerlink" title="什么是MVCC？怎么解决并发一致性问题"></a>什么是MVCC？怎么解决并发一致性问题</h4><p>多版本并发控制，创建版本号和删除版本号（创建数据行的快照时的系统版本号）</p>
<p>可重复读下，对数据行修改事务T1，读取的数据行快照的创建版本号 &lt; 事务T的版本号（比较）</p>
<p>读取的数据行快照的删除版本号 &gt; 事务T的版本号 否则表示这行数据已被删除</p>
<hr>
<h4 id="MVCC解决了哪两种隔离级别？"><a href="#MVCC解决了哪两种隔离级别？" class="headerlink" title="MVCC解决了哪两种隔离级别？"></a>MVCC解决了哪两种隔离级别？</h4><p>提交读 和 可重复读</p>
<hr>
<h4 id="如何解决幻读问题？（在X隔离级别使用XX和XX）"><a href="#如何解决幻读问题？（在X隔离级别使用XX和XX）" class="headerlink" title="如何解决幻读问题？（在X隔离级别使用XX和XX）"></a>如何解决幻读问题？（在X隔离级别使用XX和XX）</h4><p><em><strong>可重复读隔离级别 + Next-key locks</strong></em></p>
<pre><code>Next-key Lock: &#123;
    1. record lock (锁一个记录上的索引，而不是记录本身，没有索引自动在主键上创建聚簇索引)
    2. gap lock （锁定索引之间的间隙，但不包括索引本身）
&#125;
</code></pre>
<h4 id="间隙锁锁的是哪些范围？什么操作导致间隙锁"><a href="#间隙锁锁的是哪些范围？什么操作导致间隙锁" class="headerlink" title="间隙锁锁的是哪些范围？什么操作导致间隙锁"></a>间隙锁锁的是哪些范围？什么操作导致间隙锁</h4><h4 id="快照读和当前读的区别？"><a href="#快照读和当前读的区别？" class="headerlink" title="快照读和当前读的区别？"></a>快照读和当前读的区别？</h4><p>select XXX 进行快照读 从undo log中快照获取</p>
<p>select XX for update 加锁保证拿取最新的数据</p>
<p>每条记录更新同时记录一条回滚记录（回滚操作记录undo log）</p>
<hr>
<h4 id="数据库三范式？"><a href="#数据库三范式？" class="headerlink" title="数据库三范式？"></a>数据库三范式？</h4><p>第一范式：表中所有属性为最小原子属性，不可在分割 不能表中嵌套表</p>
<p>第二范式：属性对主键不存在部分函数依赖（学号、姓名、性别、年龄、课程号、分数）主键[学号、课程号]</p>
<p>第三范式：属性对主键不存在传递函数依赖（学号、姓名、学院、院长）主键[学号]</p>
<p><strong>如何解决第二、第三？（看业务场景使用不同的范式）</strong></p>
<hr>
<h4 id="undo日志用来干嘛？binlog日志？redo日志？"><a href="#undo日志用来干嘛？binlog日志？redo日志？" class="headerlink" title="undo日志用来干嘛？binlog日志？redo日志？"></a>undo日志用来干嘛？binlog日志？redo日志？</h4><ol>
<li><p>mvcc使用undo log（<em><strong>回滚日志：记录每行数据的版本</strong></em>）来实现快照 保存事务发生之前数据的快照版本，可以回滚</p>
</li>
<li><p>redo log innoDB引擎层日志（<em><strong>重做日志【往前滚- 数据页的物理修改，且只能恢复最后一次提交的位置】</strong></em>）：记录事务操作变化后数据修改之后的值，不管事务是否提交都会记录。万一DB宕机异常启动，使用redo log恢复数据。</p>
</li>
<li><p>binlog（归档日志）是二进制文件，是MySQL Server层记录的日志。MySQL主从复制中，从库用主库的binlog进行复制</p>
</li>
</ol>
<p><strong>（binlog只记录对数据的修改操作，用于主从复制、增量恢复）</strong></p>
<hr>
<h5 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h5><p>是innoDB存储引擎层的日志，用来记录数据库事务操作的变化，记录是的数据修改之后的值，无论事物是否提交都会记录。在实例或者介质crash，redolog派上用场，用来恢复数据，保证数据的完整性。</p>
<p>更新操作涉及到write ahead loging，先写日志在写磁盘。inndb先把更新语句写redo log再更新内存，语句执行完毕后，在空闲的时候或者按照设定的更新策略将redo log中内容更新到磁盘当中。</p>
<p>有了redo log，在db异常重启时候，根据redo log恢复，实现crash-safe</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1af0b4169b7d248fdb05e9d1d189b854.png" alt="RUNOOB 图标"></p>
<p><em><strong>redo日志有固定大小，写满需要重头写</strong></em></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4101e39d0acf0d31a758f0ecc2cca829.png" alt="RUNOOB 图标"></p>
<h4 id="InnoDB是如何实现事务？"><a href="#InnoDB是如何实现事务？" class="headerlink" title="InnoDB是如何实现事务？"></a>InnoDB是如何实现事务？</h4><p>InnoDB实现事务 -&gt; ACID：使用这三个日志 + 锁（排他锁/共享锁）</p>
<p>原子性：undo log(回滚日志)：记录数据修改前的状态，万一回滚恢复之前的状态</p>
<p>一致性：redo log(重做日志)：记录数据修改后的状态</p>
<p>隔离性：锁（行级锁、表锁），可分共享锁、排他锁</p>
<p>持久性：undo log(回滚日志) + redo log(重做日志)</p>
<hr>
<h4 id="binlog文件是什么？存储的数据形式有哪些？有什么优缺？"><a href="#binlog文件是什么？存储的数据形式有哪些？有什么优缺？" class="headerlink" title="binlog文件是什么？存储的数据形式有哪些？有什么优缺？"></a>binlog文件是什么？存储的数据形式有哪些？有什么优缺？</h4><p>bin log(二进制日志文件)，只记录对数据的修改操作，主要是<strong>主从复制</strong>和<strong>增量恢复</strong></p>
<p>MySQL binlog日志三种格式？</p>
<ol>
<li>Statement：每一条会修改的SQL都会记录到binlog中</li>
</ol>
<p>（优点：减少日志量 - 缺点：主从复制中，带有特定函数的SQL，从库执行可能出现不一致问题）</p>
<ol start="2">
<li>Row：不记录SQL语句上下文信息，仅保存哪条记录被修改成什么样</li>
</ol>
<p>（优点：不需要记录SQL的上下文信息，以每行记录的修改来记录，解决SQL带有特定函数的问题</p>
<p>缺点：biglog日志量大（update多条，每一条修改都会记录））</p>
<ol start="3">
<li>Mixedlevel：以上两种level混合使用</li>
</ol>
<p>[一般语句的修改使用Statement格式保存，一些函数无法则使用Row格式]</p>
<p>会根据每一条具体的SQL语句来区分记录的日志形式</p>
<hr>
<h4 id="MySQL主从复制怎么实现？"><a href="#MySQL主从复制怎么实现？" class="headerlink" title="MySQL主从复制怎么实现？"></a>MySQL主从复制怎么实现？</h4><p><strong>binlog线程、io线程、sql线程</strong></p>
<p>1.binlog dump线程将主服务器上的数据更改写入二进制文件（Binary log）</p>
<p>2.io线程负责从主服务器中读取binlog，并写入从服务器的中继日志（Relay log）</p>
<p>3.sql线程读取中继日志，解析主服务器已执行的数据修改，并在从服务器进行重放（Replay）</p>
<hr>
<h4 id="MySQL的crash-safe怎么实现的？？"><a href="#MySQL的crash-safe怎么实现的？？" class="headerlink" title="MySQL的crash-safe怎么实现的？？"></a>MySQL的crash-safe怎么实现的？？</h4><p>三个日志+WAL+2PC</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1631999">https://cloud.tencent.com/developer/article/1631999</a></p>
<hr>
<h4 id="为什么需要分库分表？"><a href="#为什么需要分库分表？" class="headerlink" title="为什么需要分库分表？"></a>为什么需要分库分表？</h4><p>数据量太大，查询效率低下</p>
<hr>
<h4 id="怎样分库分表？"><a href="#怎样分库分表？" class="headerlink" title="怎样分库分表？"></a>怎样分库分表？</h4><p>垂直拆分：按照业务（订单、商品）放在不同数据库，独立出来，就算一个业务出错不影响另一个业务，提高并发</p>
<p>缺点：无法解决单表数据越来越大的问题</p>
<p>水平拆分：将单表数据拆分多表，甚至放在不同库当中。按照日期时间划分、按照hash取模划分</p>
<p>采用Apace sharding-jdbc来作分库分表中间件</p>
<p>注意⚠️！需要做不同纬度的数据冗余，方便根据不同纬度的查询（空间换时间的方式）</p>
<hr>
<h4 id="索引优化有哪些？（哪些情况下索引会失效？）"><a href="#索引优化有哪些？（哪些情况下索引会失效？）" class="headerlink" title="索引优化有哪些？（哪些情况下索引会失效？）"></a>索引优化有哪些？（哪些情况下索引会失效？）</h4><p>只针对频繁查询的字段 设置索引</p>
<p>可以使用覆盖索引</p>
<p>避免索引失效（使用全值匹配、符合最左前缀原则[中间索引不能断]）</p>
<p><strong>失效：</strong></p>
<p>where条件后用函数、运算符</p>
<p>模糊查询 like’%冰’（使用通配符开头）</p>
<p>不符合最左原则的联合索引</p>
<p>索引字段上!= &lt;&gt;这样会导致索引失效（is NULL / is not NULL）</p>
<hr>
<h4 id="索引case！！！注意⚠️"><a href="#索引case！！！注意⚠️" class="headerlink" title="索引case！！！注意⚠️"></a>索引case！！！注意⚠️</h4><p>联合索引（a、b、c）</p>
<p>a = ‘’ and b = ‘’ and c = ‘’（全都命中索引）</p>
<p>c = ‘’ and b = ‘’ and a = ‘’（全都命中索引，有SQL优化器）***[连接器、查询缓存、分析器、优化器、执行器]***</p>
<p>a = ‘’ and c = ‘’（只有a命中，因为b没有，联合索引中间索引无）</p>
<p>a = ‘’ and b &gt; ‘’ and c = ‘’（只有a和b命中，因为b时一个范围值，算是断点）</p>
<p>如果联合索引中有主键a</p>
<p>b = ‘’ and a = ‘’ （只会走主键a，因为B+树索引结构）</p>
<hr>
<h4 id="Where和Order-by-索引字段"><a href="#Where和Order-by-索引字段" class="headerlink" title="Where和Order by 索引字段"></a>Where和Order by 索引字段</h4><p>使用联合索引idx（a,b）</p>
<pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">//可以走索引idx</span>
<span class="token keyword">where</span> <span class="token number">a</span> <span class="token operator">=</span> <span class="token string">"xx"</span> <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token number">b</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Mysql的order by 会根据创建联合索引顺序进行排序 且asc</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9641463/mysql-not-using-index-for-order-by/38071094">https://stackoverflow.com/questions/9641463/mysql-not-using-index-for-order-by/38071094</a></p>
<hr>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="Redis的五大基本类型？"><a href="#Redis的五大基本类型？" class="headerlink" title="Redis的五大基本类型？"></a>Redis的五大基本类型？</h4><ul>
<li>String </li>
<li>List </li>
<li>Set </li>
<li>SortSet </li>
<li>Hash</li>
</ul>
<hr>
<h4 id="SortSet底层数据结构是怎么存储的？"><a href="#SortSet底层数据结构是怎么存储的？" class="headerlink" title="SortSet底层数据结构是怎么存储的？"></a>SortSet底层数据结构是怎么存储的？</h4><p>有两种数据结构：<strong>压缩表ziplist和跳表skiplist</strong></p>
<ul>
<li><p>压缩表（如果有序保存元素数&lt;128 || 长度&lt;64byte）</p>
</li>
<li><p>skiplist按序保存元素分值，使用dict来保存分值和元素的对应关系（有序链表 + 多级索引结构（关键节点））</p>
<p>时间复杂度：O(logN) 空间复杂度：O(N)</p>
</li>
</ul>
<hr>
<p><strong>跳表插入数据</strong></p>
<p>1.新节点和各层索引节点逐一比较，确定原链表的插入位置。O（logN）</p>
<p>2.把索引插入到原链表。O（1）</p>
<p>3.利用抛硬币的随机方式，决定新节点是否提升为上一级索引。</p>
<p>结果为“正”则提升并继续抛硬币，结果为“负”则停止。O（logN）</p>
<p>总体上，跳跃表插入操作的时间复杂度是O（logN），而这种数据结构所占空间是2N，既空间复杂度是 O（N）。</p>
<p><strong>跳表删除数据</strong></p>
<p>1.自上而下，查找第一次出现节点的索引，并逐层找到每一层对应的节点 O(logN)</p>
<p>2.删除每一层查找到的节点，如果该层只有一个节点，删除整一层（除去原链表之外）O(logN)</p>
<p>总体来说，删除O(logN)</p>
<hr>
<h4 id="如何解决Redis存储String类型大的JSON数据格式的问题？"><a href="#如何解决Redis存储String类型大的JSON数据格式的问题？" class="headerlink" title="如何解决Redis存储String类型大的JSON数据格式的问题？"></a>如何解决Redis存储String类型大的JSON数据格式的问题？</h4><p>可以使用中间件，对大的JSON字符串格式数据进行压缩</p>
<hr>
<h4 id="Redis的过期时间是怎么实现的？"><a href="#Redis的过期时间是怎么实现的？" class="headerlink" title="Redis的过期时间是怎么实现的？"></a>Redis的过期时间是怎么实现的？</h4><p>RedisDB中有Expires字典保存DB中所有key的过期时间（过期字典）</p>
<p>键是一个指针指向数据库键</p>
<p>值是一个long类型的毫秒unix时间戳</p>
<p>判断key -&gt; 找过期字典 -&gt; 判断现在unix时间戳是否大于key的value</p>
<hr>
<h4 id="Redis的过期键删除策略有哪些（三种）分别是怎样，优缺点"><a href="#Redis的过期键删除策略有哪些（三种）分别是怎样，优缺点" class="headerlink" title="Redis的过期键删除策略有哪些（三种）分别是怎样，优缺点"></a>Redis的过期键删除策略有哪些（三种）分别是怎样，优缺点</h4><p>定时删除：key一旦到达过期时间，立马删除</p>
<p>惰性删除：当getKey的时候，发现已到过期时间就删除返回nil</p>
<p>定期删除：每隔一段时间，扫描过期key，进行删除</p>
<p>定时删除：对内存友好，但对CPU时间不友好[降低服务器吞吐量和响应时间]</p>
<p>惰性删除：对内存不友好，大量过期的key放在DB中一直不被删除</p>
<p>定期删除：前两者折中方式，每隔一段时间执行删除过期key操作，限制删除key执行时长和频率</p>
<p>惰性删除：通过读写DB之前执行expireIfNeeded函数对输入key检查（过滤器）</p>
<p>定期删除：调用activeExpireCycle函数 在规定时间内分多次遍历服务器中各个数据库，从数据库Expires字典中随机检查一部分键的过期时间，过期则删除。</p>
<hr>
<h4 id="Redis的持久化机制会有哪些（两种）分别是怎样的，优缺点"><a href="#Redis的持久化机制会有哪些（两种）分别是怎样的，优缺点" class="headerlink" title="Redis的持久化机制会有哪些（两种）分别是怎样的，优缺点"></a>Redis的持久化机制会有哪些（两种）分别是怎样的，优缺点</h4><p>RDB：对数据生成快照方式，保存键值对记录数据库，存储二进制的RDB文件（可设置每隔一段时间进行save）</p>
<p>AOF：保存对Redis执行写的操作命令，通过追加append方式添加命令</p>
<p>AOP可以设置同步参数，一秒同步，redis宕机最多丢失一秒前数据</p>
<p>如果需要对大规模数据进行恢复，对于数据完整性不是非常敏感，RDB对AOF更加高效</p>
<p>对数据量较大的进行RDB持久化，没法做到秒级来save/bgsave</p>
<p>反之，对数据完整性敏感性十足，使用AOF，做到最多丢失一秒之前的redis数据</p>
<hr>
<h4 id="AOF重写是怎样的？"><a href="#AOF重写是怎样的？" class="headerlink" title="AOF重写是怎样的？"></a>AOF重写是怎样的？</h4><p>Redis通过创建一个新的AOF文件来替换现在的AOF文件（新旧文件保存DB状态相同）</p>
<p>不读取现有的AOF文件，而直接读取服务器当前DB的键现在的值，然后用一条命令记录 代替之前多条命令</p>
<p>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。</p>
<p><strong>为了不影响处理其他命令请求，将AOF重写交给子进程（带有Master进程的副本，避免使用锁，保证数据安全）</strong></p>
<hr>
<h4 id="AOF重写期间服务器进行命令处理，导致数据不一致怎么办？"><a href="#AOF重写期间服务器进行命令处理，导致数据不一致怎么办？" class="headerlink" title="AOF重写期间服务器进行命令处理，导致数据不一致怎么办？"></a>AOF重写期间服务器进行命令处理，导致数据不一致怎么办？</h4><p>Redis创建一个AOF重写缓冲区，在创建子进程后使用</p>
<p>AOF重写期间，服务器进程工作：</p>
<ol>
<li><p>执行客户端命令</p>
</li>
<li><p>将执行后命令追加AOF缓冲区</p>
</li>
<li><p>将执行命令追加AOF重写缓冲区</p>
<p>当子进程完成AOF重写后，向父进程发信号，父进程接收到将AOF重写缓冲区中所有内容写入新AOF文件中</p>
<p>再进行新的AOF改名 原子性覆盖现有的AOF文件，完成替换</p>
</li>
</ol>
<hr>
<h4 id="AOF、RDB和复制功能对过期键的处理？"><a href="#AOF、RDB和复制功能对过期键的处理？" class="headerlink" title="AOF、RDB和复制功能对过期键的处理？"></a>AOF、RDB和复制功能对过期键的处理？</h4><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><ul>
<li><p>生成RDB文件：创建RDB文件，对数据库中key检查，会忽略过期键，只保存有用的key</p>
</li>
<li><p>载入RDB文件：（但主从服务器进行RDB文件载入，主会忽略，从会加载已过期key进去）</p>
</li>
</ul>
<hr>
<h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><ul>
<li><p>AOF文件写入：AOF会追加append 该key被删除的del命令到AOF文件中</p>
</li>
<li><p>AOF重写：和生成RDB文件一样，对DB中key检查，已过期的不会保存</p>
</li>
</ul>
<hr>
<h4 id="为什么Redis支持高并发量，速度快？"><a href="#为什么Redis支持高并发量，速度快？" class="headerlink" title="为什么Redis支持高并发量，速度快？"></a>为什么Redis支持高并发量，速度快？</h4><ol>
<li><p>Redis是内存型DB，直接对内存读写速度快</p>
</li>
<li><p>Redis使用io多路复用，可以处理并发请求，采用epoll单线程轮询多个socket方式，处理事件。</p>
</li>
</ol>
<p>（非阻塞io采用epoll，读、写、关闭、连接转化成事件，减少io时间）</p>
<ol start="3">
<li>Redis是单线程的，io多路处理的需要执行命令放在队列当中，单线程逐个执行，保证不会同时执行</li>
</ol>
<p>避免产生多线程上下文切换，或者产生死锁等，性能消耗</p>
<ol start="4">
<li><p>Redis底层数据结构，压缩表、跳表、hash..高效的存取数据结构</p>
</li>
<li><p>采用io多路复用，监听多个客户端socket，将socket事件放在队列当中，单线程处理</p>
</li>
</ol>
<p>再交给文件事件分配器处理，分给不同的事件处理器进行处理（set、get、连接请求等处理）</p>
<hr>
<h4 id="select和epoll的区别？阻塞io-非阻塞io-io多路复用-异步io分别？"><a href="#select和epoll的区别？阻塞io-非阻塞io-io多路复用-异步io分别？" class="headerlink" title="select和epoll的区别？阻塞io 非阻塞io io多路复用 异步io分别？"></a>select和epoll的区别？阻塞io 非阻塞io io多路复用 异步io分别？</h4><ol>
<li><p>select、poll用监视多个socket描述符，单线程轮询来判断数据是否就绪，就绪返回信号。还需要再一下轮询找到确定socket进行处理，而是epoll会把轮询已就绪的socket事件放在自己创建的链表中，epoll只关心链表有无数据就可。</p>
</li>
<li><p>epoll不需要通过遍历的方式，而是在内核中建立了file节点，并且通过注册响应事件的方式，当有响应事件发生时采取相应的措施，并把准备就绪的事件放入链表中，从而epoll只关心链表中是否有数据即可。</p>
</li>
<li><p>epoll只需要一次拷贝就可以 其他select需要每次遍历过后在用户态-内核态中相互拷贝</p>
</li>
</ol>
<hr>
<h4 id="Redis分片有了解吗"><a href="#Redis分片有了解吗" class="headerlink" title="Redis分片有了解吗?"></a>Redis分片有了解吗?</h4><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/692428">https://developer.aliyun.com/article/692428</a></p>
<hr>
<h4 id="Redis主从复制？"><a href="#Redis主从复制？" class="headerlink" title="Redis主从复制？"></a>Redis主从复制？</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kismetv/p/9236731.html">https://www.cnblogs.com/kismetv/p/9236731.html</a></p>
<hr>
<h4 id="Redis的高可用是怎么实现的？"><a href="#Redis的高可用是怎么实现的？" class="headerlink" title="Redis的高可用是怎么实现的？"></a>Redis的高可用是怎么实现的？</h4><ol>
<li><p>Redis提供持久化机制、主从复制（读写分离）、集群+哨兵</p>
</li>
<li><p>持久化：针对于单机备份（从内存到磁盘）</p>
</li>
<li><p> 主从复制：侧重在于多机的数据备份，实现读写分离、读的负载均衡和故障恢复</p>
</li>
</ol>
<p>   从节点保存主节点（masterhost和masterip）存储主节点的ip和port信息</p>
<p>   从节点会每秒调用定时函数replicationCron，发现主节点可以连接那就进行socket连接</p>
<p>   从节点建立事件收集器，比如接收RDB文件、接收命令</p>
<p><strong>集群+哨兵：</strong></p>
<p>在复制基础上，哨兵解决自动化的故障恢复</p>
<ul>
<li><p>哨兵监控：不断检查主节点和从节点是否运行正常</p>
</li>
<li><p>自动故障转移：当主节点不可用，升级其中一个从节点为主节点，其他从节点修改复制目标节点</p>
</li>
<li><p>配置提供者：客户端连接时通过连接哨兵，拿到当前redis主节点的地址</p>
</li>
<li><p>通知：哨兵会将故障转移的结果通知客户端</p>
</li>
</ul>
<p>集群：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。</p>
<hr>
<h4 id="Redis的内存淘汰策略有哪些？"><a href="#Redis的内存淘汰策略有哪些？" class="headerlink" title="Redis的内存淘汰策略有哪些？"></a>Redis的内存淘汰策略有哪些？</h4><p>已设置过期时间的数据集 LRU数据淘汰</p>
<p>已设置过期时间的数据集 即将过期的数据淘汰</p>
<p>已设置过期时间的数据集 选择任意数据淘汰</p>
<p>全局数据集keys LRU最近最少使用key淘汰</p>
<p>全局数据集 任意选择数据淘汰</p>
<p>禁止驱逐数据（满了存新的数据 直接报错）</p>
<hr>
<h4 id="Redis中会出现哪些问题？（雪崩、击穿、穿透）"><a href="#Redis中会出现哪些问题？（雪崩、击穿、穿透）" class="headerlink" title="Redis中会出现哪些问题？（雪崩、击穿、穿透）"></a>Redis中会出现哪些问题？（雪崩、击穿、穿透）</h4><ol>
<li><p>雪崩：keys的过期时间设置随机数值</p>
</li>
<li><p>击穿（缓存 db都没有的数据）：缓存空对象设置较短的过期时间（五分钟），或者使用bitmap设置布隆过滤器</p>
</li>
</ol>
<p>（一定不存在的数据请求会直接过滤 无法打到db）</p>
<ol start="3">
<li>穿透（热点数据缓存过期）：互斥锁，只要有一个请求访问来DB带来新的缓存，再释放锁</li>
</ol>
<hr>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h4 id="RocketMQ的实现原理是怎样？"><a href="#RocketMQ的实现原理是怎样？" class="headerlink" title="RocketMQ的实现原理是怎样？"></a>RocketMQ的实现原理是怎样？</h4><p>RocketMQ由NameServer提供服务注册、Product生产者、Consumer消费者、Broker（RocketMQ进程）</p>
<ol>
<li><p>Broker在启动时，向所有的NameServe注册，并保持长连接，每30s发送心跳</p>
</li>
<li><p>Product发送消息时，先从NameServer上获取Broker服务器地址，然后根据负载均衡算法选择一台服务器</p>
</li>
</ol>
<p>来发送消息</p>
<ol start="3">
<li>Consumer消费消息时，从NameServer上获取Broker地址，然后主动拉取消息</li>
</ol>
<hr>
<h4 id="RocketMQ怎么实现这么高的吞吐量的（高可用）？"><a href="#RocketMQ怎么实现这么高的吞吐量的（高可用）？" class="headerlink" title="RocketMQ怎么实现这么高的吞吐量的（高可用）？"></a>RocketMQ怎么实现这么高的吞吐量的（高可用）？</h4><p>RocketMQ分Product、Consumer、Broker、Name Server</p>
<ol>
<li><p>都是以集群的方式部署（可以支持多master 模式、多master多slave异步复制模式、多 master多slave同步双写模式）</p>
</li>
<li><p>支持10亿级别的消息堆积，不会因为堆积导致性能下降</p>
</li>
<li><p>支持海量的topic</p>
</li>
</ol>
<hr>
<h4 id="RocketMQ怎么保证消息不丢失？"><a href="#RocketMQ怎么保证消息不丢失？" class="headerlink" title="RocketMQ怎么保证消息不丢失？"></a>RocketMQ怎么保证消息不丢失？</h4><ol>
<li><p>producer端<br>  采用同步发送消息，回调获得发送结果是否success</p>
<p>   发送失败，会发送重试（三次）</p>
</li>
<li><p>broker端</p>
<p>设置同步刷盘（默认是异步刷盘）持久化采用CommitLog来落盘</p>
<p>集群部署，主从模式，高可用（万一master挂，使用slave继续转发[master接受到消息会同步slave]）</p>
</li>
<li><p>consumer端</p>
<p>at least once消息消费会发ack确认给broker</p>
</li>
</ol>
<hr>
<h4 id="RocketMQ的消费信息是以什么样的形式进行存储？"><a href="#RocketMQ的消费信息是以什么样的形式进行存储？" class="headerlink" title="RocketMQ的消费信息是以什么样的形式进行存储？"></a>RocketMQ的消费信息是以什么样的形式进行存储？</h4><p>ByteBuffer msgStoreItemMemory</p>
<p>[存储编码后的消息，即将消息转换成字节的方式</p>
<p>和对象的序列化不同，不仅仅有消息体内容，还加上额外信息（消息创建时间、消息生产者的host、消息体的长度、topic…）]</p>
<p>（需要查看源码确认）</p>
<hr>
<h4 id="RocketMQ怎么保证消息不重复消费？"><a href="#RocketMQ怎么保证消息不重复消费？" class="headerlink" title="RocketMQ怎么保证消息不重复消费？"></a>RocketMQ怎么保证消息不重复消费？</h4><p>生产者没必要做幂等性</p>
<p>消费者端做好幂等性，确保重复的请求不会造成影响。</p>
<p>比如：判断DB是否消费，在数据库使用唯一索引，保证消息只被消费一次。</p>
<ol>
<li>消费端处理消息的业务逻辑保持幂等性</li>
<li>保证每条消息都有唯一编号且保证消息处理成功和去重表的日志同时出现</li>
</ol>
<hr>
<h4 id="RocketMQ怎么保证消息的有序性（顺序消费）？"><a href="#RocketMQ怎么保证消息的有序性（顺序消费）？" class="headerlink" title="RocketMQ怎么保证消息的有序性（顺序消费）？"></a>RocketMQ怎么保证消息的有序性（顺序消费）？</h4><p>同一topic，同一个queue，发消息的时候一个线程去发送消息，消费的时候 一个线程去消费一个queue里的消息</p>
<blockquote>
<p>2021.11补充：</p>
</blockquote>
<h5 id="消费者的消费queue和协程关系是怎么的？一对一还是多？无序和有序消费区别是什么？"><a href="#消费者的消费queue和协程关系是怎么的？一对一还是多？无序和有序消费区别是什么？" class="headerlink" title="消费者的消费queue和协程关系是怎么的？一对一还是多？无序和有序消费区别是什么？"></a>消费者的消费queue和协程关系是怎么的？一对一还是多？无序和有序消费区别是什么？</h5><p>顺序消费是每个queue分配一个协程去处理，比如workerA从queue1中拉取，会放在buffer中</p>
<ul>
<li><p>虽然是messageBuffer数组，但无序对应是一个同一个messageChan（存放message）</p>
<p>无序：每个协程对应是同一个messageBuffer</p>
<p>有序：每个协程对应不同的messageBuffer</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称\比例</th>
<th>消息queue</th>
<th>messageBuffer</th>
<th>协程worker</th>
</tr>
</thead>
<tbody><tr>
<td>无序disOrderly</td>
<td>n</td>
<td>1</td>
<td>n</td>
</tr>
<tr>
<td>有序orderly</td>
<td>n</td>
<td>n</td>
<td>n</td>
</tr>
</tbody></table>
<hr>
<h5 id="多个协程怎么分配到对应的message，进行获取对应消息进行消费？"><a href="#多个协程怎么分配到对应的message，进行获取对应消息进行消费？" class="headerlink" title="多个协程怎么分配到对应的message，进行获取对应消息进行消费？"></a>多个协程怎么分配到对应的message，进行获取对应消息进行消费？</h5><p>无论无序消费还是有序消费，都是从协程分配的messageBuffer从获取message进行处理</p>
<ul>
<li>不同之处：<ol>
<li>无序，就算消费组重启需要变更，rebalance，需要给多个queue（消息）重新分配对应的协程，但多个协程对应还是同一个buffer，消息继续发，可能其他协程停了，但其他协程继续直接拿来就消费。</li>
<li>有序，则多个协程序对应多个buffer，可能有协程停了，对应的buffer channel没法消费，持续积压，只有rebalance完分配了新协程就可以继续消费，消费速度降低，会导致积压上升。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="同个comsumer对应多个协程从自己对应的messageBuffer获取message消费，是跟拿取的一样并发消费的吗-（有序无序）？"><a href="#同个comsumer对应多个协程从自己对应的messageBuffer获取message消费，是跟拿取的一样并发消费的吗-（有序无序）？" class="headerlink" title="同个comsumer对应多个协程从自己对应的messageBuffer获取message消费，是跟拿取的一样并发消费的吗 （有序无序）？"></a>同个comsumer对应多个协程从自己对应的messageBuffer获取message消费，是跟拿取的一样并发消费的吗 （有序无序）？</h5><ul>
<li>源码中，并发的开多协程从buffer获取消息，然后各个协程消费buffer channel，说明协程也是并发消费消息，消息分发到各个协程当中，互不影响一起消费。</li>
<li>感觉看作每个协程消费也是一个队列，多个队列并发消费。</li>
</ul>
<hr>
<h5 id="有序如何设置无限重试的？设置retryTime控制次数可不可以？"><a href="#有序如何设置无限重试的？设置retryTime控制次数可不可以？" class="headerlink" title="有序如何设置无限重试的？设置retryTime控制次数可不可以？"></a>有序如何设置无限重试的？设置retryTime控制次数可不可以？</h5><p>可以（两个条件是或者的关系）</p>
<hr>
<p>一个topic下有多个队列，为了保证有序，RocketMQ提供了MessageQueueSelector队列选择机制</p>
<p>我们可使用Hash取模法，让同一个订单发送到同一个队列中，再使用同步发送，只有同个订单的创建消息发送成功，再发送支付消息。这样，我们保证了发送有序。<strong>【在同个队列中消息是有序】</strong></p>
<hr>
<p>RocketMQ仅保证顺序发送，顺序消费由消费者业务保证!!!（消费端幂等性）</p>
<p>生产者顺序发送，消费者顺序消费setOrderly = true</p>
<hr>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p>应用层 表示层 会话层 传输层 网络层 数据链路层 物理层</p>
<hr>
<h4 id="TCP-IP四层体系模型？"><a href="#TCP-IP四层体系模型？" class="headerlink" title="TCP/IP四层体系模型？"></a>TCP/IP四层体系模型？</h4><p>应用层、传输层、网际层、网络接口层</p>
<hr>
<h4 id="TCP-IP（参考）模型与OSI七层模型有什么异同？"><a href="#TCP-IP（参考）模型与OSI七层模型有什么异同？" class="headerlink" title="TCP/IP（参考）模型与OSI七层模型有什么异同？"></a>TCP/IP（参考）模型与OSI七层模型有什么异同？</h4><p>OSI七层模型是站在完整、宏观纬度上计算机网络分层</p>
<p>TCP/IP四层模型是围绕TCP/IP网络中通信协议来进行分层</p>
<hr>
<h4 id="HTTP基本组成？"><a href="#HTTP基本组成？" class="headerlink" title="HTTP基本组成？"></a>HTTP基本组成？</h4><p>header + body</p>
<h4 id="HTTP常见字段有哪些？"><a href="#HTTP常见字段有哪些？" class="headerlink" title="HTTP常见字段有哪些？"></a>HTTP常见字段有哪些？</h4><p>Host字段（服务器域名）</p>
<p>Content-length（服务端返回的数据长度）</p>
<p>Content-type（服务端回应，告诉客户端这次数据是什么格式，text/html; charset=utf-8）</p>
<p>Content-Encoding：gzip（服务端返回数据是什么压缩格式）</p>
<p>Connection（客户端要求服务器TCP持久连接，请求复用keep-alive）</p>
<hr>
<h4 id="HTTP常见的状态码有哪些？"><a href="#HTTP常见的状态码有哪些？" class="headerlink" title="HTTP常见的状态码有哪些？"></a>HTTP常见的状态码有哪些？</h4><p>200 请求ok</p>
<p>301 永久重定向</p>
<p>302 临时重定向</p>
<p>400 bad request 客户端请求报文有误</p>
<p>404 not found客户端请求资源服务端不存在</p>
<p>403 forbidden 客户端无权限访问资源</p>
<p>500 内部服务器错误</p>
<p>502 bad gatway 服务端作为网关或者代理时返回错误码</p>
<p>503 服务器忙，无法回应</p>
<hr>
<h4 id="301-302状态码的区别？"><a href="#301-302状态码的区别？" class="headerlink" title="301 302状态码的区别？"></a>301 302状态码的区别？</h4><p>301永久重定向</p>
<p>302临时重定向</p>
<hr>
<h4 id="HTTP有哪些请求操作？分别"><a href="#HTTP有哪些请求操作？分别" class="headerlink" title="HTTP有哪些请求操作？分别"></a>HTTP有哪些请求操作？分别</h4><p>get、post、put、delete、head、options、patch</p>
<p>Get和Post区别</p>
<p>HTTP哪些请求是安全和幂等的？</p>
<p>get head options</p>
<h4 id="HTTP的优缺点分别是？"><a href="#HTTP的优缺点分别是？" class="headerlink" title="HTTP的优缺点分别是？"></a>HTTP的优缺点分别是？</h4><p>明文传输（易窃听）</p>
<p>无法验证通信双方的身份（易伪装）</p>
<p>无法证明报文的完整性（易篡改）</p>
<h4 id="为什么HTTP是无状态的？"><a href="#为什么HTTP是无状态的？" class="headerlink" title="为什么HTTP是无状态的？"></a>为什么HTTP是无状态的？</h4><p>使用无状态的，应对大量的请求只需要来了服务端接收请求，处理完断开连接。</p>
<p>减轻服务端设计，不然每个访问网站的用户，服务器都要保存他们信息，是服务器负担</p>
<p>cookie和session？</p>
<p>HTTP和HTTPS有什么区别？</p>
<p>什么是对称加密/非对称加密？</p>
<p>HTTPS怎么加密的(混合加密)？</p>
<p>TCP的三次握手、四次挥手过程是怎样？</p>
<hr>
<h4 id="为什么说TCP是可靠的？（超时重传）"><a href="#为什么说TCP是可靠的？（超时重传）" class="headerlink" title="为什么说TCP是可靠的？（超时重传）"></a>为什么说TCP是可靠的？（超时重传）</h4><p>TCP的流量控制、拥塞控制是怎样实现？（丢包）</p>
<p>（慢开始、拥塞避免、快重传、快恢复）</p>
<p>发送方维护一个拥塞窗口（cwnd）状态变量</p>
<p>慢开始：发送的报文数令cwnd=1，发送方只能发送一个报文段；当收到确认后，将cwnd加倍</p>
<p>2、4、8、16….（报文段数量）</p>
<p>拥塞避免：设置了（阈值）ssthresh，当cwnd &gt;= ssthresh，进入拥塞避免，每轮只将cwnd + 1</p>
<p>超时情况：如果出现了超时，将ssthresh = cwnd/2，重新执行 -&gt; 慢启动</p>
<p>快重传：接收方每次接收到报文段，都会对最后一个有序报文段进行确认。ex：已收到M1、M2、现在接收到M4，</p>
<p>应当对M2进行确认。发送方接收到<strong>三次重复</strong>的确认，就知道下一个报文段丢失，立即快重传M3</p>
<p>属于个别报文段丢失，执行快恢复，ssthresh = cwnd/2，cwnd = ssthresh，直接进入拥塞避免</p>
<h5 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h5><p>使用TCP、UDP的例子？</p>
<p>什么是ARP协议</p>
<p>什么是ICMP协议</p>
<p>什么是DNS</p>
<p>什么DHCP</p>
<hr>
<h3 id="海量数据场景问题"><a href="#海量数据场景问题" class="headerlink" title="海量数据场景问题"></a>海量数据场景问题</h3><p>bitMap</p>
<p>使用最小堆</p>
<p>spring三级缓存</p>
<p>cms和g1垃圾收集器</p>
<hr>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="进程的几种状态"><a href="#进程的几种状态" class="headerlink" title="进程的几种状态"></a>进程的几种状态</h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ac9ce2afd126">https://www.jianshu.com/p/ac9ce2afd126</a></p>
<p>就绪、进行、阻塞</p>
<h4 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pange1991/article/details/53860651">https://blog.csdn.net/pange1991/article/details/53860651</a></p>
<p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306580742045730">https://www.liaoxuefeng.com/wiki/1252599548343744/1306580742045730</a></p>
<ul>
<li><p>New：新创建的线程，尚未执行；</p>
</li>
<li><p>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</p>
</li>
<li><p>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</p>
</li>
<li><p>Waiting：运行中的线程，因为某些操作在等待中；</p>
</li>
<li><p>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</p>
</li>
<li><p>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</p>
</li>
</ul>
<h4 id="输入url到返回数据有用到哪些协议？"><a href="#输入url到返回数据有用到哪些协议？" class="headerlink" title="输入url到返回数据有用到哪些协议？"></a>输入url到返回数据有用到哪些协议？</h4><p>DNS协议、TCP协议、IP协议、ARP协议、HTTP协议</p>
<h5 id="过程？"><a href="#过程？" class="headerlink" title="过程？"></a>过程？</h5><blockquote>
<p> DNS解析、TCP连接、发送HTTP请求、服务端处理请求返回HTTP报文、浏览器解析渲染、连接结束</p>
</blockquote>
<h5 id="Mysql-explain-各字段解释"><a href="#Mysql-explain-各字段解释" class="headerlink" title="Mysql explain 各字段解释"></a>Mysql explain 各字段解释</h5><blockquote>
<p> <a target="_blank" rel="noopener" href="https://juejin.cn/post/6850418120998256654">https://juejin.cn/post/6850418120998256654</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/argleary/article/details/104189850">https://blog.csdn.net/argleary/article/details/104189850</a></p>
</blockquote>
<hr>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li><p>有哪些参数？怎么设置？工作机制？</p>
</li>
<li><p>拒绝策略有哪些？</p>
</li>
</ul>
<blockquote>
<p>核心线程数、最大线程数、空闲时间存活时间、存活时间单位unit、阻塞队列、拒绝策略</p>
<p>拒绝策略：静默丢弃、直接抛异常、交给调用方处理、丢弃队伍中最老的任务</p>
</blockquote>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://ruihuachen.github.io/2021/04/11/知识点记忆点-补充/%20Ernest's blog%20知识点记忆点-补充" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2021/04/19/2021-04-19/" title="2021/04/19有感"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 2021/04/19有感</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2021/04/02/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="Java基础知识点归纳">Next post: Java基础知识点归纳&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://ruihuachen.github.io" rel="noopener noreferrer">Ernest's blog</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>